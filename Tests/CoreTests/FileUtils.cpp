#include <catch2/catch.hpp>

#include <iostream>
#include <Core/FileUtils.h>
#include <Core/StringUtils.h>

#pragma optimize("", off)

namespace
{
	const std::string c_FileContents = "This is a file generated by CoreTests/FileUtils.cpp\n"
		"If you happen to find this, you do not need it.\n"
		"Feel free to delete it.";
	const std::string c_FlatFileContents = "This is a file generated by CoreTests/FileUtils.cpp"
		"If you happen to find this, you do not need it."
		"Feel free to delete it.";
}

TEST_CASE("Project directories can be retrieved properly")
{
	std::string projectDirectory = core::FileUtils::GetProjectDirectory();
	std::string codeDirectory = core::FileUtils::GetCodeDirectory();
	std::string dataDirectory = core::FileUtils::GetDataDirectory();

	// Slightly scuffed - but ensures the directory was retrieved for testing purposes
	bool sadProjectDirectoryExists = projectDirectory.find("sad") != std::string::npos;
	REQUIRE(sadProjectDirectoryExists);

	bool sadCodeDirectoryExists = codeDirectory.find("sad") != std::string::npos && codeDirectory.find("Code") != std::string::npos;
	REQUIRE(sadCodeDirectoryExists);

	bool sadDataDirectoryExists = dataDirectory.find("sad") != std::string::npos && dataDirectory.find("Data") != std::string::npos;
	REQUIRE(sadDataDirectoryExists);
}

TEST_CASE("Platform specific project directories are created properly")
{
	std::string testPath = "sad/TestPath/Testing";
	std::string osPath = core::FileUtils::ConvertOSPathString(testPath);

#ifdef _SAD_WINDOWS
	// testPath should have Windows-style back slashes in the returned path
	REQUIRE_FALSE(core::StringUtils::Equals(osPath, testPath));
	REQUIRE(core::StringUtils::Equals(osPath, "sad\\TestPath\\Testing"));
#else
	// testPath should still contain Unix-style forward slashes in the returned path
	REQUIRE_FALSE(core::StringUtils::Equals(osPath, "sad\\TestPath\\Testing"));
	REQUIRE(core::StringUtils::Equals(osPath, testPath));
#endif
}

TEST_CASE("Files can be created, read, and removed successfully")
{
	std::string testPath = core::FileUtils::GetDataDirectory() + core::FileUtils::ConvertOSPathString("/TestFile.txt");
	REQUIRE(core::FileUtils::WriteFile(testPath, c_FileContents));

	SECTION("files without line breaks return properly")
	{
		// Validate read contents of the created file
		std::string testFileContents = core::FileUtils::ReadFile(testPath);
		REQUIRE(core::StringUtils::Equals(testFileContents, c_FlatFileContents));
	}

	SECTION("files with line breaks return properly")
	{
		// Validate read contents of the created file
		// ReadFile will add an extra line break at the end of strings as a result of 'true' being passed
		std::string testFileContents = core::FileUtils::ReadFile(testPath, true);
		REQUIRE(core::StringUtils::Equals(testFileContents, c_FileContents));
	}
	
	REQUIRE(core::FileUtils::RemoveFile(testPath));
}

TEST_CASE("Files can be mutated successfully")
{ 
	std::string testPath = core::FileUtils::GetDataDirectory() + core::FileUtils::ConvertOSPathString("/TestFile.txt");
	REQUIRE(core::FileUtils::WriteFile(testPath, c_FileContents));

	SECTION("appending to file")
	{
		std::string appendedString = "Adding another test line.";
		REQUIRE(core::FileUtils::AppendFile(testPath, appendedString));
		
		// Validate that the expected string matches the appended file contents
		// Read the string back with line breaks since the string inserted to the file also had line breaks
		std::string expectedString = c_FileContents + "\n" + appendedString;
		std::string testFileContents = core::FileUtils::ReadFile(testPath, true);

		// New file contents shouldn't match the original
		REQUIRE_FALSE(core::StringUtils::Equals(testFileContents, c_FileContents));
		REQUIRE(core::StringUtils::Equals(testFileContents, expectedString));
	}

	SECTION("overwriting pre-existing file")
	{
		std::string testPath = core::FileUtils::GetDataDirectory() + core::FileUtils::ConvertOSPathString("/TestFile.txt");
		REQUIRE(core::FileUtils::WriteFile(testPath, c_FileContents));

		std::string overwrittenString = "Replacing the file with this test line.";
		REQUIRE(core::FileUtils::WriteFile(testPath, overwrittenString));

		std::string testFileContents = core::FileUtils::ReadFile(testPath);

		// New file contents shouldn't match the original
		REQUIRE_FALSE(core::StringUtils::Equals(testFileContents, c_FileContents));
		REQUIRE(core::StringUtils::Equals(testFileContents, overwrittenString));
	}

	REQUIRE(core::FileUtils::RemoveFile(testPath));
}